<!DOCTYPE html>
<html>
<head>
		<meta http-equiv="content-type" content="text/html" charset="ISO-8859-1">
		
		<title>The Gallery</title>

		<link rel="stylesheet" type="text/css" href="./css/main.css" media="screen" />
		
		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script> 
		<script src="js/ColladaLoader.js"></script>
		<script src="js/PointerLockControls.js"></script>
</head>


<body>

<div id="blocker">
	<div id="instructions">
		<span id="title"> Click to Play </span>
		<br>
		<span id="sub">W,A,S,D = Move around, Mouse = Look around, Space = Jump.</span>
	</div>
</div>

<script>
	if(!(Detector.webgl)) //if no support for WebGL
	{
		alert("Your browser does not support WebGL!");
	}
	else {
	var UNIV = {}; //Using YUI module system in order to prevent variable overlap with other libraries. 
	UNIV.controls;
	//blocker displays the controls, and tells user to click on the screen to play
	UNIV.blocker = document.getElementById('blocker');
	UNIV.instructions = document.getElementById('instructions');

	//check to make sure we have pointerLock capability in users browser
	UNIV.havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

	if(UNIV.havePointerLock) {
		UNIV.element = document.body;
		UNIV.pointerlockchange = function( event ) {
			if(document.pointerLockElement === UNIV.element || document.mozPointerLockElement === UNIV.element || document.webkitPointerLockElement === UNIV.element) {
				UNIV.controls.enabled = true;
				UNIV.blocker.style.display = 'none';
			} else {
				UNIV.controls.enabled = false;

				UNIV.blocker.style.display = '-webkit-box';
				UNIV.blocker.style.display = '-moz-box';
				UNIV.blocker.style.display = 'box';

				UNIV.instructions.style.display = '';
			}		
		}
		UNIV.pointerlockerror = function(event) { //event refers to any actions done by keyboard or mouse.
		UNIV.instructions.style.display = '';
		}
		
		//adding listeners for the pointer lock change and for pointer lock error
		document.addEventListener('pointerlockchange', UNIV.pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', UNIV.pointerlockchange, false);
		document.addEventListener('webkitpointerlockchange',UNIV.pointerlockchange, false);

		document.addEventListener('pointerlockerror',UNIV.pointerlockerror, false);
		document.addEventListener('mozpointerlockerror',UNIV.pointerlockerror, false);
		document.addEventListener('webkitpointerlockerror',UNIV.pointerlockerror, false);

		//clicking on the screen should result in controls getting activated and blocker becoming hidden
		UNIV.instructions.addEventListener('click',function(event) {
			UNIV.instructions.style.display = 'none';
			UNIV.blocker.style.display = 'none';
			
			//asking browser to lock browser
			UNIV.element.requestPointerLock = UNIV.element.requestPointerLock || UNIV.element.mozRequestPointerLock || UNIV.element.webkitRequestPointerLock;

			if ( /Firefox/i.test( navigator.userAgent ) ) {
				var fullscreenchange = function ( event ) {
					if ( document.fullscreenElement === UNIV.element || document.mozFullscreenElement === UNIV.element || document.mozFullScreenElement === UNIV.element ) {

						document.removeEventListener( 'fullscreenchange', fullscreenchange );
						document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

						UNIV.element.requestPointerLock();
					}			
				}
				//disables automatic transition to full screen, a default of disabling browser(???)
				document.addEventListener( 'fullscreenchange', fullscreenchange, false );
				document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

				UNIV.element.requestFullscreen = UNIV.element.requestFullscreen || UNIV.element.mozRequestFullscreen || UNIV.element.mozRequestFullScreen || UNIV.element.webkitRequestFullscreen;

				UNIV.element.requestFullscreen();
			} else {
				UNIV.element.requestPointerLock();
			}
		}, false );

		} else {instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API'; }


//////////////////////////////////////MAIN SCENE////////////////////////////////////////
	var GALLERY = {}; //objects that pertain to our main scene are under global var GALLERY
	
	GALLERY.scene = new THREE.Scene();
	GALLERY.scene.fog = new THREE.FogExp2(0xdddddd, 0.0011);
	
	GALLERY.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
	
	GALLERY.objects = [];
	
	UNIV.controls = new THREE.PointerLockControls(GALLERY.camera);
	
	GALLERY.scene.add(UNIV.controls.getObject());
	
	GALLERY.raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
	
	//look into image compression in order to allow antialias to be true and fluid	
	GALLERY.renderer = new THREE.WebGLRenderer({antialias: false}); 
	GALLERY.renderer.setSize(window.innerWidth, window.innerHeight);
	GALLERY.renderer.setClearColor( 0xffffff, 1); //background color
	document.body.appendChild(GALLERY.renderer.domElement);


	//Change the size of the canvas if resized
	window.addEventListener('resize', function() {
		UNIV.WIDTH = window.innerWidth;
		UNIV.HEIGHT = window.innerHeight;
		GALLERY.renderer.setSize(UNIV.WIDTH, UNIV.HEIGHT);
		GALLERY.camera.aspect = UNIV.WIDTH / UNIV.HEIGHT;
		GALLERY.camera.updateProjectionMatrix();
	});


	////////////////////LIGHTING////////////////////
	//hemisphere light, lights the whole scene, but is rendered directly
	//above the user. Thus specularity is most reflective right below the user
	GALLERY.hemiLight = new THREE.HemisphereLight(0xffffff, 0xeeeeee, .99); 
	GALLERY.hemiLight.position.y = 198;
	GALLERY.scene.add(GALLERY.hemiLight);



	/////////////////FLOOR////////////////////////
	//The material allows for a specularity found in polished floors 
	//first need to load the texture and set it to repeat
	GALLERY.floortext = THREE.ImageUtils.loadTexture("img/Floor.jpg");
	GALLERY.floortext.wrapS = THREE.RepeatWrapping;
	GALLERY.floortext.wrapT = THREE.RepeatWrapping;
	GALLERY.floortext.repeat.set(24,24);
	
	GALLERY.floormaterial = new THREE.MeshPhongMaterial({ map: GALLERY.floortext });
	
	GALLERY.floor = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), GALLERY.floormaterial);
	GALLERY.floor.rotation.x = Math.PI/2;
	GALLERY.floor.rotation.y = Math.PI;

	GALLERY.scene.add(GALLERY.floor);


	/////////////////WALLS////////////////////
	GALLERY.boundingBox = new THREE.BoxGeometry(1000,200,182);
	GALLERY.boxMaterial = new THREE.MeshLambertMaterial( {color: 0xffffff} );
	GALLERY.boxMaterial.side = THREE.BackSide;

	GALLERY.walls = new THREE.Mesh(GALLERY.boundingBox, GALLERY.boxMaterial);
	GALLERY.walls.position.y = 99.5;
	
	GALLERY.scene.add(GALLERY.walls);


	/////////////////PAINTINGS//////////////////////
	var num_of_paintings = 30;
	var paintings = [];
	for(var i = 0; i < num_of_paintings-1; i++){
		(function(i) {
			var artwork = new Image();
			var ratiow = 0;
			var ratioh = 0;

			artwork.onload = function(){

			ratiow = artwork.width/10;
			ratioh = artwork.height/10;
			// plane for artwork
			var plane = new THREE.Mesh(new THREE.PlaneGeometry(ratiow, ratioh),img); //width, height
			plane.overdraw = true;
			if(i <= Math.floor(num_of_paintings/2))
			{
				plane.position.set(65*i - 65*Math.floor(num_of_paintings/4), 48 , -90);
			}
			else
			{
				plane.position.set(65*i - 75*Math.floor(num_of_paintings/2) - 15*Math.floor(num_of_paintings/2), 48, 90);
				plane.rotation.y = Math.PI;
			}

			GALLERY.scene.add(plane);
			GALLERY.objects.push(plane);
			}
			var source = './img/Artworks/' + (i+1).toString() + '.jpg';
			console.log(source);
			artwork.src = source;
			var img = new THREE.MeshBasicMaterial({ //CHANGED to MeshBasicMaterial
			map:THREE.ImageUtils.loadTexture(artwork.src)
			});

			img.map.needsUpdate = true; //ADDED
		}(i))
	}

	///////////////ANIMATION/////////////////////
	var render = function () {
		requestAnimationFrame(render); 
		
		UNIV.controls.isOnObject(false);
		GALLERY.raycaster.ray.origin.copy(UNIV.controls.getObject().position);
		GALLERY.raycaster.ray.origin.y -= 10;

		var intersections = GALLERY.raycaster.intersectObject(GALLERY.objects);
		if(intersections.length > 0) {
			UNIV.controls.isOnObject(true);
		}
		UNIV.controls.update();

		GALLERY.renderer.render(GALLERY.scene, GALLERY.camera);
	};

	render();
}; //closes else statement of webGL detector.
</script>
</body>
</html>
