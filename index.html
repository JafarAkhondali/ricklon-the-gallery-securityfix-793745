<html>
<head>
		<meta http-equiv="content-type" content="text/html" charset=ISO-8859-1">
		<!-- Optimizing for mobile -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
		
		<title>The Gallery</title>
		<style>canvas { width: 100%; height: 100% }</style>
		<style type="text/css">
			body {
			/* Hide the scrollbars */
			overflow: hidden;
			font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
			font-weight: 300;
			color: #666670;
			}
		</style>
		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script> 
</head>


<body>
<div id="overlaytext" style="position: absolute; top: 15px; left: 15px;">
Controls: <br/>
Arrow keys to move around<br/>
WASD to look around<br/>
Scroll to zoom<br/>
Enter to perform action
</div>

<script>
var render;
if(!(Detector.webgl)) //if no support for WebGL
{
	alert("Your browser does not support WebGL :(");
}
else {
var scene = new THREE.Scene();




var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
var xRotation = 0.0;
var yRotation = 0.0;
var xSpeed = 0.0;
var ySpeed = 0.0;




var renderer = new THREE.WebGLRenderer({antialias:false}); //antialias set to true if not taxing
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor( 0xffffff, 1); //background color
document.body.appendChild(renderer.domElement);

//may not need it....
var mainLight = new THREE.AmbientLight(0x101010, 1.0); // lights whole world, but no shadows
mainLight.position = camera.position; //constantly updated(?)
scene.add(mainLight);

//Akin to sun, lights the whole world
var topLight = new THREE.DirectionalLight(0xdddddd, 1.0);
topLight.position.y = 15;
scene.add(topLight);

var geometry = new THREE.BoxGeometry(1,1,1);
var material = new THREE.MeshBasicMaterial({color: 0x0070aa});
var cube = new THREE.Mesh(geometry, material);
scene.add(cube);



camera.position.z = 5;


//Event listener for when keys are pressed.
//events are passed to the function onDocumentKeyDown
document.addEventListener("keydown", onDocumentKeyDown, false);


//When a key is pushed down, execute this event
function onDocumentKeyDown(event){
	//gets the key pressed
	var keyCode = event.which;

	console.log(keyCode); //Use P to display whatever you want
	if(keyCode == 80)
	{
		console.log(camera.rotation.x);
	}


	/* POV CONTROLS NEED TO BE LOCAL, BASED ON CURRENT ORIENTATION OF CAMERA
	NOT ON THE WORLD ORIENTATION OF CAMERA */

	//POV CONTROLS
	//right arrow key
	if(keyCode == 39) {
	camera.translateX(0.05);
	}
	//left arrow key
	else if (keyCode == 37){
	camera.translateX(-0.05);
	}
	//up arrow key
	else if (keyCode == 38) {
	camera.translateZ(-0.05);
	}
	//down arrow key
	else if (keyCode == 40){
	camera.translateZ(0.05);
	}

	//CAMERA ROTATION CONTROLS
	//PROBLEMS: ROTATION BASED ON RADIANS. DOES NOT RESET TO 0 WHEN 2PI COVERED
	//D Key
	if(keyCode == 68) {
			if(ySpeed >= -0.01)
			{
			ySpeed -= 0.0025;
			}
	}
	//A Key
	else if (keyCode == 65){
		if(ySpeed <= 0.01) {
		ySpeed += 0.0025;
	}
	}
	//W Key
	else if (keyCode == 87) {
		if(xSpeed <= 0.01) // || camera.rotation.x < .25 || camera.rotation.x > -.25)
		{
		xSpeed += 0.0025;
		}
		/*
		else 
		{
		xSpeed = 0.0;
		}
		*/
	}
	//S Key
	else if (keyCode == 83){
		//CURRENTLY LIMITING SPEED TO .01
		if(xSpeed >= -0.01) // || camera.rotation.x > -.25 || camera.rotation.x < .25)
		{
		xSpeed -= 0.0025;
		}
		/*
		else
		{
		xSpeed = 0.0;
		}
		*/
	}
}

var render = function () {
requestAnimationFrame(render); //recursive function based on browsers' inner timer

cube.rotation.x += 0.01;
cube.rotation.y += 0.01;


//CAMERA MOVEMENT
xRotation += xSpeed;
yRotation += ySpeed;
//x is up/down, y is left/right
camera.rotation.set(xRotation, yRotation, 0.0);

renderer.render(scene, camera);
};

render();
}
</script>
</body>
</html>
