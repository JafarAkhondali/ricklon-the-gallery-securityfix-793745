<html>
<head>
		<meta http-equiv="content-type" content="text/html" charset="ISO-8859-1">
		<!-- Optimizing for mobile -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
		
		<title>The Gallery</title>
		<style>canvas { width: 100%; height: 100% }</style>
		<style type="text/css">
			body {
			/* Hide the scrollbars */
			overflow: hidden;
			font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
			font-weight: 300;
			color: #666670;
			}
		</style>
		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script> 
		<script src="js/ColladaLoader.js"></script>
</head>


<body>
<div id="overlaytext" style="position: absolute; top: 15px; left: 15px;">
Controls: <br/>
Arrow keys to move around<br/>
WASD to look around<br/>
Scroll to zoom<br/>
Enter to perform action
</div>

<script>
var render;
if(!(Detector.webgl)) //if no support for WebGL
{
	alert("Your browser does not support WebGL :(");
}
else {
var scene = new THREE.Scene();


var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
var xRotation = 0.0; //Camera's rotation
var yRotation = 0.0; 
var xSpeed = 0.0; //camera's velocity/accel for rotation
var ySpeed = 0.0;
var xTranslation = 0.0; //camera's translation
var zTranslation = 5.0;
var xSpeedT = 0.0; //camera's translation vel/accel
var zSpeedT = 0.0;


//Change the size of the canvas if resized
window.addEventListener('resize', function() {
var WIDTH = window.innerWidth,
HEIGHT = window.innerHeight;
renderer.setSize(WIDTH, HEIGHT);
camera.aspect = WIDTH / HEIGHT;
camera.updateProjectionMatrix();
});



var renderer = new THREE.WebGLRenderer({antialias:true}); //antialias set to true if not taxing
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor( 0xffffff, 1); //background color
document.body.appendChild(renderer.domElement);

//Akin to sun, lights the whole world
var topLight = new THREE.DirectionalLight(0xdddddd, 1.0);
topLight.position.y = 15;
topLight.position.z = 15;
scene.add(topLight);

var cameraLight = new THREE.DirectionalLight(0xdddddd,1.0);
cameraLight.position.z = camera.position.z;
cameraLight.position.y = camera.position.y + 3;
cameraLight.position.x = camera.position.x;
scene.add(cameraLight);





//THE MODELS THE MODELS THE MODELS
/*
var loader = new THREE.ColladaLoader();

		loader.options.convertUpAxis = true;

		loader.load( 'test.dae', function ( collada ) {

		var dae = collada.scene;

		var skin = collada.skins[ 0 ];

		dae.position.set(0,0,2);
		dae.scale.set(.5,.5,.5);

		scene.add(dae);
});
*/
//THIS UPLOADS YOUR PHOTOS. NEEDS TO BE A LOOP DOE

var num_of_paintings = 30;
var paintings = [];
for(var i = 0; i < num_of_paintings-1; i++){
	(function(i) {
		var artwork = new Image();
		var ratiow = 0;
		var ratioh = 0;

		artwork.onload = function(){

		ratiow = artwork.width / artwork.width;
		ratioh = artwork.height / artwork.width;
		// plane for artwork
		var plane = new THREE.Mesh(new THREE.PlaneGeometry(ratiow, ratioh),img); //width, height
		plane.overdraw = true;
		plane.position.set(i, 1 , 0);
		scene.add(plane);
		}
		var source = './img/Artworks/' + (i+1).toString() + '.jpg';
		console.log(source);
		artwork.src = source;
		var img = new THREE.MeshBasicMaterial({ //CHANGED to MeshBasicMaterial
		map:THREE.ImageUtils.loadTexture(artwork.src)
		});

		img.map.needsUpdate = true; //ADDED
	}(i))
}

//SPECIAL THANKS TO MATT CONDON FOR THE ABOVE CODE HE IS A LIFE SAVER. MUCH LOVEEEEEEEEEEE.



// FLOOR
var floorTexture = new THREE.ImageUtils.loadTexture( 'img/MarbleFloor1.jpg' );
floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
floorTexture.repeat.set( 10, 10 );
var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
var floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.position.y = -0.5;
floor.rotation.x = Math.PI / 2;
scene.add(floor);
camera.position.z = zTranslation;
camera.position.y = 1;


//When a key is pushed down, execute this event
function onDocumentKeyDown(event){
	//gets the key pressed
	var keyCode = event.which;

	console.log(keyCode); //Use P to display whatever you want
	if(keyCode == 80)
	{
		console.log(camera.rotation.x);
	}


	/* POV CONTROLS NEED TO BE LOCAL, BASED ON CURRENT ORIENTATION OF CAMERA
	NOT ON THE WORLD ORIENTATION OF CAMERA */

	//POV CONTROLS
	//right arrow key
	if(keyCode == 39) {
		if(xSpeedT <= 0.020)
		{
		xSpeedT += 0.0025;
		}
	}
	//left arrow key
	else if (keyCode == 37){
		if(xSpeedT >= -0.020)
		{
		xSpeedT -= 0.0025;
		}
	}
	//up arrow key
	else if (keyCode == 38) {
		if(zSpeedT >= -0.020){
		zSpeedT -= 0.0025;
		}
	}
	//down arrow key
	else if (keyCode == 40){
		if(zSpeedT <= 0.020)
		{
		zSpeedT += 0.0025;
		}
	}

	//CAMERA ROTATION CONTROLS
	//PROBLEMS: ROTATION BASED ON RADIANS. DOES NOT RESET TO 0 WHEN 2PI COVERED
	//D Key
	if(keyCode == 68) {
			if(ySpeed >= -0.01)
			{
			ySpeed -= 0.0025;
			}
	}
	//A Key
	else if (keyCode == 65){
		if(ySpeed <= 0.01) {
		ySpeed += 0.0025;
	}
	}
	//W Key
	else if (keyCode == 87) {
		if(xSpeed <= 0.01) // || camera.rotation.x < .25 || camera.rotation.x > -.25)
		{
		xSpeed += 0.0025;
		}
		/*
		else 
		{
		xSpeed = 0.0;
		}
		*/
	}
	//S Key
	else if (keyCode == 83){
		//CURRENTLY LIMITING SPEED TO .01
		if(xSpeed >= -0.01) // || camera.rotation.x > -.25 || camera.rotation.x < .25)
		{
		xSpeed -= 0.0025;
		}
		/*
		else
		{
		xSpeed = 0.0;
		}
		*/
	}
}

//Event listener for when keys are pressed.
//events are passed to the function onDocumentKeyDown
document.addEventListener("keydown", onDocumentKeyDown, false);

function keyup(){
	console.log("Proceeding to reset");
	xSpeed = 0;
	ySpeed = 0;
	xSpeedT = 0;
	zSpeedT = 0;
}

window.onkeyup = keyup;


var render = function () {
requestAnimationFrame(render); //recursive function based on browsers' inner timer

//CAMERA MOVEMENT
xTranslation += xSpeedT;
zTranslation += zSpeedT;
//camera.position.set(xTranslation, 0.0, zTranslation);
//the following translates with respect to local axis not Global like above!
camera.translateX(xSpeedT);
camera.translateZ(zSpeedT);

xRotation += xSpeed;
yRotation += ySpeed;
//x is up/down, y is left/right
//camera.rotation.set(xRotation, yRotation, 0.0);
camera.rotateX(xSpeed);
camera.rotateY(ySpeed);

renderer.render(scene, camera);
};

render();
}
</script>
</body>
</html>
